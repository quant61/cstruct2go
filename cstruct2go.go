package main

import (
	"bufio"
	"flag"
	"fmt"
	"io"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"strconv"
	"strings"
)

var typeEquivalents map[string]string = map[string]string{
	"bool":     "bool",
	"int":      "int",
	"int8_t":   "int8",
	"int16_t":  "int16",
	"int32_t":  "int32",
	"int64_t":  "int64",
	"uint8_t":  "uint8",
	"uint16_t": "uint16",
	"uint32_t": "uint32",
	"uint64_t": "uint64",
	"char":     "byte",
	"char*":    "string",
	"float":    "float32",
	"double":   "float64",
}

func check(e error) {
	if e != nil {
		panic(e)
	}
}

type StructField struct {
	Name      string
	CType     string
	IsPointer bool
	IsArray   bool
	ArraySize int
}

type StructDef struct {
	Name   string
	Fields []StructField
}

func main() {
	input_file := flag.String("i", "./test_structs.h", "Input file")
	output_file := flag.String("o", "", "Output file, will have the same name as the input file if not set")
	package_name := flag.String("p", "main", "Package name")
	enable_format := flag.Bool("f", true, "Set to false if you do not want to format the file(or go is not installed on the system")
	bool_type := flag.String("btype", "bool", "Translate bool to different type")
	capitalize := flag.Bool("c", true, "Capitalizes names, Set to false if you do not want the structs and members accessible outside the package")

	flag.Parse()
	flags_string := fmt.Sprintf("Generated with flags: -p=%v -f=%v -btype=%v", *package_name, *enable_format, *bool_type)

	if *bool_type != "bool" {
		typeEquivalents["bool"] = *bool_type
	}
	out_file := ""
	if *output_file == "" {
		out_file = filepath.Base(*input_file)
	} else {
		out_file = *output_file
	}
	out_file = strings.TrimSuffix(out_file, filepath.Ext(out_file))
	out_file = fmt.Sprintf("%s.go", out_file)
	all_structs := createStructsFromFile(*input_file, *capitalize)
	all_structs = fixPointersAndArrays(all_structs)
	writeToFile(all_structs, out_file, *package_name, flags_string)
	if *enable_format {
		formatFile(out_file)
	}

}

func fixPointersAndArrays(sts []StructDef) []StructDef {
	for _, st := range sts {
		for index, field := range st.Fields {
			match, _ := regexp.MatchString("([a-z]+)\\[\\d\\]", field.Name)
			if match {
				split := strings.Split(field.Name, "[")
				field.Name = split[0]
				field.IsArray = true
				field.ArraySize, _ = strconv.Atoi(strings.TrimSuffix(split[1], "]"))
			}

			if strings.HasPrefix(field.Name, "*") {
				field.Name = strings.TrimPrefix(field.Name, "*")
				field.IsPointer = true
			}
			st.Fields[index] = field
		}
	}
	return sts
}

func formatFile(filename string) {
	cmd := exec.Command("go", "fmt", filename)
	err := cmd.Run()
	check(err)
}

func writeToFile(defs []StructDef, filename string, packageName string, flag_string string) {
	file, err := os.Create(filename)
	check(err)
	defer file.Close()
	io.WriteString(file, fmt.Sprintf("package %s\n\n", packageName))
	io.WriteString(file, "// WARNING: THIS IS AN AUTOGENERATED FILE, DO NOT EDIT!!\n")
	io.WriteString(file, "//\n")
	io.WriteString(file, "// This file was generated using cstruct2go(http://github.com/shrikantpatnaik/cstruc2go)\n")
	io.WriteString(file, fmt.Sprintf("// %s\n", flag_string))
	io.WriteString(file, "//\n")
	for _, st := range defs {
		io.WriteString(file, fmt.Sprintf("type %s struct {\n", st.Name))
		for _, field := range st.Fields {
			fieldtype := typeEquivalents[field.CType]
			if field.IsArray == true {
				fieldtype = fmt.Sprintf("[%d]%s", field.ArraySize, fieldtype)
			}
			if field.IsPointer == true {
				fieldtype = fmt.Sprintf("*%s", fieldtype)
			}
			io.WriteString(file, fmt.Sprintf("\t%s %s\n", field.Name, fieldtype))
		}
		io.WriteString(file, "}\n")
	}
}
func createStructsFromFile(filename string, capitalize bool) []StructDef {

	var struct_decl bool = false
	var struct_begin bool = false
	var struct_name0 string
	// `typedef struct {...} Name` or `struct Name {...}`
	var isTypeDef = false
	_ = isTypeDef

	var current_struct *StructDef
	var all_structs []StructDef = make([]StructDef, 0, 100)

	file, err := os.Open(filename)
	if err != nil {
		log.Fatal(err)
	}
	defer file.Close()

	scanner := bufio.NewScanner(file)
	startRe := regexp.MustCompile(`^\s*(typedef)?\s*struct\s*([a-zA-Z_][a-zA-Z_\d]*)?\s*(\{)?$`)
	for scanner.Scan() {
		line := strings.Replace(scanner.Text(), "\t", "  ", -1)
		if struct_decl {
			if line == "{" {
				struct_begin = true
				current_struct = new(StructDef)
				current_struct.Fields = make([]StructField, 0, 100)
			} else if strings.Contains(line, "}") {
				s := splitAndRemoveInitialSpaces(line)
				newStructDef := current_struct
				var struct_name string
				if len(s) > 1 {
					struct_name = trimSemiColons(s[1])
				}
				// in case of struct without typedef
				if struct_name == "" {
					struct_name = struct_name0
				}
				if capitalize {
					struct_name = strings.Title(struct_name)
				}
				newStructDef.Name = struct_name
				length := len(all_structs)
				all_structs = all_structs[0 : length+1]
				all_structs[length] = *newStructDef
				struct_begin = false
				struct_decl = false
			} else if struct_begin == true {
				s := splitAndRemoveInitialSpaces(line)
				length := len(current_struct.Fields)
				current_struct.Fields = current_struct.Fields[0 : length+1]
				field_name := trimSemiColons(s[1])
				if capitalize {
					field_name = strings.Title(field_name)
				}
				current_struct.Fields[length] = StructField{Name: field_name, CType: s[0]}
			}
			// } else if line == "typedef struct" {
			// 	struct_decl = true
			// 	m := startRe.FindStringSubmatch(line)
			// 	fmt.Printf("%q\n", m)
		} else {
			m := startRe.FindStringSubmatch(line)
			if len(m) == 0 {
				continue
			}
			isTypeDef = m[1] == "typedef"
			// for `struct typename` without typedef
			struct_name0 = m[2]
			struct_decl = true
			// `{` is often on the same line as struct declaration
			if m[3] == "{" {
				struct_begin = true
				current_struct = new(StructDef)
				current_struct.Fields = make([]StructField, 0, 100)
			}
		}
	}

	if err := scanner.Err(); err != nil {
		log.Fatal(err)
	}

	return all_structs
}

func trimSemiColons(str string) string {
	return strings.Trim(str, ";")
}

func splitAndRemoveInitialSpaces(str string) []string {
	s := strings.Split(str, " ")
	i := 0
	for s[i] == "" {
		i++
	}
	return s[i:]

}
